---
title: "Data Processing"
format: html
---

# Data processing

This document cleans and prepares the FIES 2023 data for the analysis of the VAT burden by income in the Philippines.

I have several objectives in cleaning/processing this dataset:

1.  Categorize the expenditure items in the FIES 2023 data into vatable and exempt
2.  Categorize the expenditure items into major expenditure groupings e.g., food, beverages, health, education, durable items, transportation, etc.
3.  Decide on the income groupings to be used for the analysis, either use deciles, or use a combination of deciles and quitiles for a more detailed presentation of the data, i.e., lowest 2 deciles, 2nd-4th quintile, then highest 2 deciles.
4.  Estimate the budget shares of each income group:

-   By major expenditure grouping
-   By taxable/exempt status

5.  Estimate the amounts of VAT paid of each income group:

-   In absolute peso amounts - in order to get how much each income group contributes to the total VAT collection
-   as percentage share to total income
-   as percentage share to total expenditure

6.  Estimate the VAT revenue forgone from the level of exempt expenditures, do this by income group. Q: Who benefits from the VAT exemptions?
7.  Estimate the effective tax rate for each decile, i.e., the ratio of vat payments to total expenditure for each decile

## Setup

```{python}
import pandas as pd
import numpy as np
import polars as pl
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

# Set display options
pd.set_option('display.max_columns', None)
pd.set_option('display.width', None)
# Set global Polars display format
pl.Config.set_float_precision(2)
pl.Config.set_tbl_formatting("ASCII_MARKDOWN")
pl.Config.set_tbl_width_chars(1000)
```

Load and check shape of datasets

```{python}
# polars equivalent
exempt_list = pl.read_csv('clean_data/vat_exempt_list.csv')
fies_raw = pl.read_parquet('clean_data/FIES2023_VOL2_COMPLETE_MONTHLY_RFACT-ADJUSTED.parquet')  # main FIES dataset

fies_raw.shape
fies_raw.head(10)
fies_raw.columns
fies_raw.dtypes
exempt_list.schema
```

## Fixing rows/columns

I need to use the exempt list data as basis to categorize the taxability of different expenditure items in the FIES dataset. The exempt list contains item codes and their VAT status (vatable or exempt). Item codes can be matched to the main FIES dataset, but they are stored as column names instead of row names in the exempt list data.

```{python}
## FOR FIES_RAW
def clean_item_code(code):
    """Remove first 6 characters and add leading zero if exactly 6 chars remain."""
    cleaned = code[6:]
    return "0" + cleaned if len(cleaned) == 6 else cleaned

def extract_major_code(code):
    """Extract first 2 characters for major category code."""
    return code[:2]

exempt_list = exempt_list.with_columns([
    pl.col('item_code')
      .cast(pl.Utf8)
      .map_elements(clean_item_code, return_dtype=pl.Utf8)
      .alias('new_item_code'),
    
    pl.col('item_code')
      .cast(pl.Utf8)
      .map_elements(clean_item_code, return_dtype=pl.Utf8)
      .map_elements(extract_major_code, return_dtype=pl.Utf8)
      .alias('item_code_major')
])

    
## FOR EXEMPT_LIST - # standardize column names to match with exempt_list df
def rename_column_name(col):
    """Remove TOTAL_ prefix and add leading zero if needed"""
    if col.startswith('TOTAL_'):
        code = col[6:]  # Remove 'TOTAL_'
        return "0" + code if len(code) == 6 else code
    return col

# Apply transformation
fies_raw = fies_raw.rename({col: rename_column_name(col) for col in fies_raw.columns})

# Check results
print(exempt_list[['item_code_major','new_item_code', 'item_code', 'description', 'vatable']].head())

```

## Vatable and exempt expenditures

VAT in the Philippines is generally applied to goods and services at a 12% standard tax rate. Some items are VAT-exempt as provided under Section 109 of the Tax Code. These are basic commodities, food items, medicines, education, and health expenditures. Further, the expenditures of specific groups are exempted such as those of senior citizens and PWDs.

Now, I need to create the following groupings: - Expenditure items into vatable and exempt - Major expenditure groupings e.g., food, beverages, health, education, durable items, transportation, etc.

```{python}
# Create lists for vatable and exempt items
vatable_items = (
    exempt_list
    .filter(pl.col('vatable') == 'vatable')
    .select('new_item_code')
    .to_series()
    .to_list()
)

exempt_items = (
    exempt_list
    .filter(pl.col('vatable') == 'exempt')
    .select('new_item_code')
    .to_series()
    .to_list()
)

# One-line version
# vatable_items = exempt_list.filter(pl.col('vatable') == 'vatable').select('new_item_code').to_series().to_list()) 

# Check results
print(f"Number of vatable items: {len(vatable_items)}")
print(f"Sample exempt codes: {exempt_items[:5]}")

exempt_list.get_column('item_code_major').to_list() #get the list of values in the item_code_major column
exempt_list.get_column('item_code_major').value_counts()#.to_dict()  #count the instance per value of item_code_major column

```

::: {style="color: red; font-style: italic;"}
**Question: Do I also need to create groupings for major expenditure categories before I do the matching between the 2 datasets?**
:::

## Major expenditure groupings

```{python}
# Create lists for items included in each major expenditure category

def get_expenditure_items(df, major_code):
    """Get list of expenditure item codes for a given major category."""
    return (
        df
        .filter(pl.col('item_code_major') == major_code)
        .select('new_item_code')
        .to_series()
        .to_list()
    )
    
# Define category mapping
category_codes = {
    'food': '01',
    'alcohol_cigs': '02',
    'clothing': '03',
    'water_elec': '04',
    'furnishings': '05',
    'health': '06',
    'transport': '07',
    'ict': '08',
    'recreation': '09',
    'education': '10',
    'resto_accom': '11',
    'insurance_financial': '12',
    'personal_care': '13',
    'family_occasions': '15',
    'other_disbursements': '17'
}

# Create all lists in one loop
expenditure_categories = {
    name: get_expenditure_items(exempt_list, code)
    for name, code in category_codes.items()
}

# Use as needed
# Option A: Extract to individual variables
food = expenditure_categories['food']
alcohol_cigs = expenditure_categories['alcohol_cigs']

# Option B: Use dictionary directly (no extraction)
pl.sum_horizontal(expenditure_categories['food']).alias('food_exp')

```

## Estimate VAT burden

1.  Taxable/Exempt status by income group (What portion of each household's spending are taxable? exempt?)

```{python}
# Calculate share of spending that is taxable/exempt by decile
# Expenditure units are in monthly pesos for total household population
tax_share = (
    fies_raw
    .with_columns([
        pl.sum_horizontal(vatable_items).alias('vatable_spending'),
        pl.sum_horizontal(exempt_items).alias('exempt_spending')
    ])
    .with_columns((pl.col('vatable_spending') + pl.col('exempt_spending')).alias('total_spending'))
    .group_by('NPCINC').agg([
        # pl.len().alias('households'),
        pl.sum('RFACT').alias('number_households'),
        pl.sum('TOINC').alias('total_income'),
        pl.sum('TOTEX').alias('total_HH_expenditures'), #original TOTEX from FIES
        pl.sum('vatable_spending').alias('vatable_expenditures'),
        pl.sum('exempt_spending').alias('exempt_expenditures'),
        pl.sum('total_spending').alias('total_expenditures')
    ])
    .sort('NPCINC')
    .with_columns([
        (pl.col('vatable_expenditures') / pl.col('total_expenditures') * 100).alias('vatable_share_exp'),
        (pl.col('exempt_expenditures') / pl.col('total_expenditures') * 100).alias('exempt_share_exp'),
        (pl.col('vatable_expenditures') / pl.col('total_income') * 100).alias('vatable_share_income'),
        (pl.col('exempt_expenditures') / pl.col('total_income') * 100).alias('exempt_share_income'),
        (pl.col('vatable_expenditures') / pl.col('total_HH_expenditures') * 100).alias('vatable_share_HHexp'),
        (pl.col('exempt_expenditures') / pl.col('total_HH_expenditures') * 100).alias('exempt_share_HHexp')
    ])
)
print(tax_share)

# Calculate overall distribution across deciles
tax_share_bydecile = (
    tax_share
    .with_columns([
        # Share of total vatable expenditure by decile
        (pl.col('vatable_expenditures') / pl.col('vatable_expenditures').sum() * 100)
        .alias('vatable_share_decile'),
        # Share of total exempt expenditure by decile
        (pl.col('exempt_expenditures') / pl.col('exempt_expenditures').sum() * 100)
        .alias('exempt_share_decile')
    ])
)
print(tax_share_bydecile)

# Export results
tax_share.write_csv('tax_share_month_rfact.csv')
tax_share_bydecile.write_csv('outputs/tax_share_bydecile_month_rfact.csv')

```

2.  Budget shares by major expenditure category and by income group

```{python}
budget_share = (
    fies_raw
    .with_columns([
        pl.sum_horizontal(expenditure_categories[name]).alias(name)
        for name in expenditure_categories
    ])
    .group_by('NPCINC').agg(
        [pl.sum('RFACT').alias('number_households')] +
        [pl.sum(name) for name in expenditure_categories]
    )
    .sort('NPCINC')
    .with_columns(
        pl.sum_horizontal([pl.col(name) for name in expenditure_categories]).alias('total_expenditures')
    )
    .with_columns([
        (pl.col(category) / pl.col('total_expenditures') * 100).alias(f'{category}_share')
        for category in expenditure_categories
    ])
)
print(budget_share)

# Export results
budget_share.write_csv('outputs/budget_share_month_rfact.csv') 

```

3.  Estimated VAt payments by income group

-   How much total VAT is paid by each decile?
-   What is the proportion of VAT paid to their total income? total expenditure?

Estimate the effective tax rate for each decile, i.e., the ratio of vat payments to total expenditure for each decile **Effective tax rate** can be derived using the tax_shares dataframe, i.e., total vatable expenditures divided by total expenditures for each decile is similar when those figures are multiplied by the VAT rate of 12%.

```{python}
# This is ratio of total VAT paid of each decile to total potential VAT of each decile (i.e. total expenditures * 12%)

vat_rate = 0.12

vat_paid_est = (
    tax_share_bydecile
    .with_columns([
        (pl.col('vatable_expenditures') * vat_rate).alias('estimated_vat_paid'),
        ((pl.col('vatable_expenditures') * vat_rate) / pl.col('total_expenditures') * 100).alias('effective_vat_rate'),
    ])
    .with_columns([
        ((pl.col('estimated_vat_paid') / (pl.col('total_expenditures') * vat_rate)) * 100).alias('vat_to_expenditure'),
        # ((pl.col('vatable_expenditures') * (vat_rate / (1 + vat_rate))) / pl.col('TOINC') * 100).alias('vat_to_income')
    ])
)
print(vat_paid_est)

# Alternatively, get the effective VAT rate for each HH and get the mean effective VAT rate for each decile

avg_vat_etr = (
    fies_raw
    .with_columns([
        (pl.sum_horizontal(vatable_items) * vat_rate).alias('estimated_vat_perHH'),
        (pl.sum_horizontal(vatable_items) + pl.sum_horizontal(exempt_items)).alias('total_expenditures')
    ])
    .with_columns([
        ((pl.col('estimated_vat_perHH') / pl.col('total_expenditures')) * 100).alias('vat_paid_to_total_expenditures')
    ])
    .group_by('NPCINC')
    .agg([
        pl.sum('RFACT').alias('number_households'),
        pl.mean('vat_paid_to_total_expenditures').alias('avg_vat_etr')
    ])
    .sort('NPCINC')
)

# Adding VAT etr to the original fies_raw df

fies_raw_vat_etr = (
    fies_raw
    .with_columns([
        pl.sum_horizontal(vatable_items).alias('total_vatable_expenditures'),
        pl.sum_horizontal(exempt_items).alias('total_exempt_expenditures')
    ])
    .with_columns([
        (pl.col('total_vatable_expenditures') + pl.col('total_exempt_expenditures')).alias('total_expenditures'),
        (pl.col('total_vatable_expenditures') * vat_rate).alias('estimated_vat_perHH'),
        (pl.col('total_exempt_expenditures') * vat_rate).alias('estimated_vat_foregone')
    ])
    .with_columns([
        ((pl.col('estimated_vat_perHH') / pl.col('total_expenditures')) * 100).alias('vat_paid_to_total_expenditures'),
        ((pl.col('estimated_vat_foregone') / pl.col('total_expenditures')) * 100).alias('vat_foregone_to_total_expenditures')
    ])
)

# export data as parquet file
fies_raw_vat_etr.write_parquet('clean_data/fies_raw_vat_etr')

```

4.  Estimate the VAT revenue forgone from the level of exempt expenditures, do this by income group. Q: Who benefits from the VAT exemptions?
5.  Shortcut to estimate effective VAT rate and VAT forgone

```{python}
fies_raw_vat_etr = pl.read_parquet('clean_data/fies_raw_vat_etr')

# This sums the weighted values first, then calculates the ratio, giving you the true population-level ETR.
main_summary = (
    fies_raw_vat_etr
    .group_by('NPCINC')
    .agg([
        pl.sum('RFACT').alias('number_households'),
        pl.sum('total_vatable_expenditures').alias('total_vatable_expenditures'),
        pl.sum('total_exempt_expenditures').alias('total_exempt_expenditures'),
        pl.sum('total_expenditures').alias('total_expenditures'),
        pl.sum('estimated_vat_perHH').alias('total_vat_paid'),
        pl.sum('estimated_vat_foregone').alias('total_vat_foregone')
        ])
    .with_columns([
        (pl.col('total_vat_paid') / pl.col('total_expenditures') * 100).alias('avg_vat_etr'),
        (pl.col('total_vat_foregone') / pl.col('total_expenditures') * 100).alias('avg_vat_foregone_etr')
    ])
    .sort('NPCINC')
)
    
## Formula: Weighted Mean = Σ(ratio × weight) / Σ(weight)
## I need a weighted mean of the ratios using RFACT as weights.
main_summary2 = (
    fies_raw_vat_etr
    .group_by('NPCINC')
    .agg([
        pl.sum('RFACT').alias('number_households'),
        pl.sum('total_vatable_expenditures').alias('total_vatable_expenditures'),
        pl.sum('total_exempt_expenditures').alias('total_exempt_expenditures'),
        pl.sum('total_expenditures').alias('total_expenditures'),
        pl.sum('estimated_vat_perHH').alias('total_vat_paid'),
        pl.sum('estimated_vat_foregone').alias('total_vat_foregone'),
        
        # Weighted sum of ratios (ratio × weight)
        (pl.col('vat_paid_to_total_expenditures') * pl.col('RFACT')).sum().alias('weighted_sum_vat_etr'),
        (pl.col('vat_foregone_to_total_expenditures') * pl.col('RFACT')).sum().alias('weighted_sum_foregone_etr')
    ])
    .with_columns([
        # Weighted mean = weighted sum / sum of weights
        (pl.col('weighted_sum_vat_etr') / pl.col('number_households')).alias('avg_vat_etr'),
        (pl.col('weighted_sum_foregone_etr') / pl.col('number_households')).alias('avg_vat_foregone_etr')
    ])
    .sort('NPCINC')
)

# Export results
main_summary2.write_csv('outputs/main_summary2.csv') 

```

## Focusing on exempt expenditure categories

1.  Out of the total exempt expenditures, what portions are from food? health? etc?
2.  Who benefits from exempting food items? public transport? education? health? 

Based on the data, 40% of the total food expenditures of the tenth decile are exempt, while only 14% of the total food expenditures of the richest decile are exempt. 

```{python}
# Breakdown of exempt expenditures

# First, identify which categories have exempt items
categories_with_exempts = {
    name: [col for col in expenditure_categories[name] if col in exempt_items]
    for name in expenditure_categories.keys()
}
categories_with_exempts = {k: v for k, v in categories_with_exempts.items() if len(v) > 0}

# Then process only those categories
exempt_by_category = (
    fies_raw_vat_etr
    .with_columns([
        pl.sum_horizontal(cols).alias(f'{name}_exempt')
        for name, cols in categories_with_exempts.items()
    ])
    .group_by('NPCINC')
    .agg([
        pl.sum('RFACT').alias('number_households'),
        pl.sum('total_vatable_expenditures').alias('total_vatable_expenditures'),
        pl.sum('total_exempt_expenditures').alias('total_exempt_expenditures'),
        pl.sum('total_expenditures').alias('total_expenditures')
    ] + [
        pl.sum(f'{name}_exempt').alias(f'{name}_exempt')
        for name in categories_with_exempts.keys()
    ])
    .sort('NPCINC')
    # Get the share of each exempt category to total exempt expenditures for each decile
    .with_columns([
        ((pl.col('food_exempt') / pl.col('total_expenditures')) * 100).alias('food_exempt_share'),
        ((pl.col('water_elec_exempt') / pl.col('total_expenditures')) * 100).alias('water_elec_exempt_share'),
        ((pl.col('furnishings_exempt') / pl.col('total_expenditures')) * 100).alias('furnishings_exempt_share'),
        ((pl.col('health_exempt') / pl.col('total_expenditures')) * 100).alias('health_exempt_share'),
        ((pl.col('transport_exempt') / pl.col('total_expenditures')) * 100).alias('transport_exempt_share'),
        ((pl.col('recreation_exempt') / pl.col('total_expenditures')) * 100).alias('recreation_exempt_share'),
        ((pl.col('education_exempt') / pl.col('total_expenditures')) * 100).alias('education_exempt_share'),
        ((pl.col('insurance_financial_exempt') / pl.col('total_expenditures')) * 100).alias('insurance_financial_exempt_share')
    ])
)

print(exempt_by_category)
exempt_by_category.write_csv('outputs/exempt_by_category.csv') 

```

## 

## Documentation Notes

**Data Source**: FIES 2023 Volume 2, Philippine Statistics Authority

**Key Variables Identified**: - Household ID: `SEQ_NO` - Regional identifiers: `W_REGN`, `W_PROV` - Expenditure variables: Variables starting with `TOTAL_` - Income variables: To be identified in main dataset

**VAT Rate**: 12% (standard rate in Philippines as of 2023)

**Assumptions**: - VAT is embedded in final prices (tax-inclusive pricing) - Basic commodities (rice, basic food items) are generally VAT-exempt - Processed foods, beverages, manufactured goods are VAT-taxable

**Next Steps**: 1. Load actual FIES 2023 microdata 2. Identify exact income variable names 3. Map expenditure categories to VAT tax status 4. Run full cleaning pipeline 5. Validate results against known income distribution patterns

Get summary stats for each decile for Total income and total expenditure

```{python}
# Simple chain-based approach for TOINC and TOTEX by decile
decile_summary = (
    fies_raw
    .group_by('NPCINC')
    .agg([
        # Count households
        pl.len().alias('households'),
        
        # Sum
        pl.col('TOINC').sum().alias('total_income'),
        pl.col('TOTEX').sum().alias('total_expenditure'),
        
        # Average
        pl.col('TOINC').mean().alias('avg_income'),
        pl.col('TOTEX').mean().alias('avg_expenditure')
    ])
    .sort('NPCINC')
)

print(decile_summary)
# Export to Excel
decile_summary.to_pandas().to_excel('decile_summary.xlsx', index=False, sheet_name='Decile_Summary')

```


# Display some summary statistics using Polars
```{python}
summary_stats = (
    vat_analysis
    .select([
        pl.len().alias('total_households'),
        pl.col('total_vatable_expenditure').mean().alias('avg_vatable_expenditure'),
        pl.col('total_exempt_expenditure').mean().alias('avg_exempt_expenditure'),
        pl.col('vat_amount').mean().alias('avg_vat_amount'),
        pl.col('vat_burden_percent').mean().alias('avg_vat_burden_percent'),
        pl.col('vat_burden_percent').median().alias('median_vat_burden_percent')
    ])
)

print(summary_stats)

```

## 4. Data Cleaning Functions

```{python}
def clean_fies_data(df):
    """
    Clean FIES data for VAT burden analysis
    
    Parameters:
    df (DataFrame): Raw FIES data
    
    Returns:
    DataFrame: Cleaned data
    """
    df_clean = df.copy()
    
    # Remove rows with missing household ID
    df_clean = df_clean.dropna(subset=['SEQ_NO'])
    
    # Convert expenditure columns to numeric
    expenditure_cols = [col for col in df_clean.columns if col.startswith('TOTAL_')]
    for col in expenditure_cols:
        df_clean[col] = pd.to_numeric(df_clean[col], errors='coerce')
    
    # Fill missing expenditure values with 0
    df_clean[expenditure_cols] = df_clean[expenditure_cols].fillna(0)
    
    return df_clean

def calculate_income_quintiles(df, income_col):
    """
    Calculate income quintiles for households
    
    Parameters:
    df (DataFrame): Household data
    income_col (str): Name of total income column
    
    Returns:
    DataFrame: Data with income quintiles
    """
    df_with_quintiles = df.copy()
    
    # Calculate quintiles
    df_with_quintiles['income_quintile'] = pd.qcut(
        df_with_quintiles[income_col], 
        q=5, 
        labels=['Q1_Poorest', 'Q2_Poor', 'Q3_Middle', 'Q4_Rich', 'Q5_Richest']
    )
    
    return df_with_quintiles

def calculate_vat_burden(df, vat_rate=0.12):
    """
    Calculate VAT burden for each household
    
    Parameters:
    df (DataFrame): Household data with expenditures
    vat_rate (float): VAT rate (default 12% for Philippines)
    
    Returns:
    DataFrame: Data with VAT calculations
    """
    df_vat = df.copy()
    
    # Identify VAT-taxable expenditure columns
    # This would need to be customized based on actual FIES variable names
    vat_cols = [col for col in df_vat.columns if col.startswith('TOTAL_') and 
                any(keyword in col.lower() for keywords in vat_taxable_categories.values() 
                    for keyword in keywords)]
    
    # Calculate total VAT-taxable expenditure
    df_vat['total_vat_taxable_expenditure'] = df_vat[vat_cols].sum(axis=1)
    
    # Calculate VAT amount (embedded in prices)
    df_vat['vat_amount'] = df_vat['total_vat_taxable_expenditure'] * (vat_rate / (1 + vat_rate))
    
    # Calculate VAT burden as percentage of income
    # Note: Replace 'TOTAL_INCOME' with actual income variable name
    # df_vat['vat_burden_pct'] = (df_vat['vat_amount'] / df_vat['TOTAL_INCOME']) * 100
    
    return df_vat
```

## 5. Data Processing Pipeline

```{python}
# This section would process the actual FIES data
# Uncomment and modify when you have the main dataset

# # Load and clean data
# fies_data = pd.read_csv('fies_2023_data.csv')
# fies_clean = clean_fies_data(fies_data)

# # Calculate income quintiles
# fies_with_quintiles = calculate_income_quintiles(fies_clean, 'TOTAL_INCOME')

# # Calculate VAT burden
# fies_final = calculate_vat_burden(fies_with_quintiles)

# # Create summary statistics
# summary_stats = fies_final.groupby('income_quintile').agg({
#     'TOTAL_INCOME': ['mean', 'median'],
#     'total_vat_taxable_expenditure': ['mean', 'median'],
#     'vat_amount': ['mean', 'median'],
#     'vat_burden_pct': ['mean', 'median']
# }).round(2)

# print("Summary statistics by income quintile:")
# print(summary_stats)
```



##